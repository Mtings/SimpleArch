Http原理和具体工作机制-[详解](https://juejin.cn/post/6844903872935247886)
=====
## Http原理
Http是一种应用层协议，即超文本传送协议(Hypertext Transfer Protocol )，是Web联网的基础，也是手机联网常用的协议之一，
HTTP协议是建立在TCP协议之上的一种应用。HTTP连接最显著的特点是客户端发送的每次请求都需要服务器回送响应，在请求结束后，
会主动释放连接。从建立连接到关闭连接的过程称为“一次连接”。  
1）在HTTP 1.0中，客户端的每次请求都要求建立一次单独的连接，在处理完本次请求后，就自动释放连接。
 
2）在HTTP 1.1中则可以在一次连接中处理多个请求，并且多个请求可以重叠进行，不需要等待一个请求结束后再发送下一个请求。
 
由于HTTP在每次请求结束后都会主动释放连接，因此HTTP连接是一种“短连接”，要保持客户端程序的在线状态，需要不断地向服务器发起连接
请求。通常的做法是即时不需要获得任何数据，客户端也保持每隔一段固定的时间向服务器发送一次“保持连接”的请求，服务器在收到该请求后对客户端进行回
复，表明知道客户端“在线”。若服务器长时间无法收到客户端的请求，则认为客户端“下线”，若客户端长时间无法收到服务器的回复，则认为网络已经断开。

## Http的请求行
* 请求行包括 请求方法Method、统一资源标志符Request-URI、HTTP协议版本HTTP-Version
例如：GET www.baidu.com HTTP/1.1  

## 各种请求方法的含义
1) GET: 请求指定的页面信息，并返回实体主体。
2) HEAD: 类似于get请求，只不过返回的响应中没有具体的内容，用于获取报头
3) POST: 向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。  
POST请求可能会导致新的资源的建立和/或已有资源的修改。
4) PUT: 从客户端向服务器传送的数据取代指定的文档的内容。
5) DELETE: 请求服务器删除指定的页面。
## 各种状态码的意义
### 状态码划分：
100〜199的状态码是 HTTP / 1.1 向协议中引入了信息性状态码；
200〜299的状态码表示成功；
300〜399的状态码指资源重定向；
400〜499的状态码指客户端请求出错；
500〜599的状态码指服务端出错；
| 状态码      | 说明              |
| -----      | -----             |
| 200        | 响应成功           |
| 302        | 跳转，跳转地址通过响应头中的位置属性指定（JSP中Forward和Redirect之间的区别）|
| 400        | 客户端请求有语法错误，不能被服务器识别              |
| 403	     | 服务器接收到请求，但是拒绝提供服务（认证失败）       |
| 404	     | 请求资源不存在      |
| 500	     | 服务器内部错误      |

## Http的Header和Body的详解
### Header: 请求头部为请求报文添加了一些附加信息，由“名/值”对组成，每行一对，名和值之间使用冒号分隔。并且在请求头部的最后会有一个空行，表示请求头部结束，这一行必不可少
### 响应头部则为响应报文添加了一些附加信息
请求头部
| 请求头部字段名      | 说明                  |
| -----             | -----                 |
| Accept            | 用户代理可以处理的媒体类型  |
| Accept-Encoding   | 通知服务端可以发送的数据压缩格式 |
| Accept-Charset	| 通知服务端可以发送的编码格式   |
| Accept-Language	| 通知服务端可以发送的语言  |
| Authorization     | Web认证信息            |
| Host	            | 请求资源所在的服务器     |
| if-Modified-Since	| 比较资源的更新时间       |
| User-Agent	    | 接受请求的服务器地址，可以是IP:端口号，也可以是域名 |

响应头部
| 响应头部字段名       | 说明                  |
| -----             | -----                 |
| Server            | 服务器应用程序软件的名称和版本 |
| Content-Type	    | 响应正文的类型（是图片还是二进制字符串）例如：application/json;charset=UTF-8 |
| Content-Length	| 响应正文长度            |
| Content-Charset	| 响应正文使用的编码       |
| Content-Encoding	| 响应正文使用的数据压缩格式 |
| Content-Language	| 响应正文使用的语言       |

### Body: 请求体body一般用来存储post的参数和参数数据，body常用的有以下几种数据格式
1) multipart/form-data : 以表单形式提交，主要是上传文件用它
2) application/x-www-from-urlencoded : 以键值对的数据格式提交，当action为post时，浏览器将form数据封装到http body中，  
然后发送server。这个格式不能提交文件
3) application/json: json传参
4) application/xml: xml传参

## [REST到底是什么](https://www.zhihu.com/question/28557115)?

## 对称加密和非对称加密的含义和各自的优缺点
1) 对称加密：使用相同的密匙对同一密码进行加密和解密
2) 非对称加密：非对称加密有两个钥匙，及公钥（Public Key）和私钥（Private Key）。公钥和私钥是成对的存在，如果对原文使用公钥加密，
则只能使用对应的私钥才能解密；因为加密和解密使用的不是同一把密钥，所以这种算法称之为非对称加密算法。非对称加密算法的密匙是通过一系列
算法获取到的一长串随机数，通常随机数的长度越长，加密信息越安全。通过私钥经过一系列算法是可以推导出公钥的，也就是说，公钥是基于私钥
而存在的。但是无法通过公钥反向推倒出私钥，这个过程的单向的。
3) 优缺点：
对称加密
* 优点：算法简单，加密解密容易，效率高，执行快。
* 缺点：相对来说不算特别安全，只有一把钥匙，密文如果被拦截，且密钥也被劫持，那么，信息很容易被破译。
非对称加密
* 优点：安全，即使密文被拦截、公钥被获取，但是无法获取到私钥，也就无法破译密文。作为接收方，务必要保管好自己的密钥。
* 缺点：加密算法及其复杂，安全性依赖算法与密钥，而且加密和解密效率很低。

## [Base64的含义、缺点和变种](https://juejin.cn/post/6844904197519835150)
* Base64 是一种基于 64 个可打印字符来表示二进制数据的表示方法。由于 2⁶ = 64 ，所以每 6 个比特为一个单元，对应某个可打印字符。
3 个字节有 24 个比特，对应于 4 个 base64 单元，即 3 个字节可由 4 个可打印字符来表示。Base64 常用于在处理文本数据的场合，
表示、传输、存储一些二进制数据，包括 MIME 的电子邮件及 XML 的一些复杂数据。
* Base64 是一种数据编码方式，目的是为了保障数据的安全传输。但标准的 base64 编码无需额外的信息，即可以进行解码，是完全可逆的。
因此在涉及传输私密数据时，并不能直接使用 base64 编码，而是要使用专门的对称或非对称加密算法。
* 变种：Base64 URL 是标准Base64编码的一个变种，分别用 -、_ 替换标准Base64编码结果中的 + 、 / ，并删除结果最后的 = 。

## 序列化的含义、目的
* 把对象转换为字节序列，也就是指，将一个 JAVA 对象所描述的所有内容以文件 IO 的方式写入二进制文件的一个过程
* 意义：序列化机制允许将实现序列化的Java对象转换位字节序列，这些字节序列可以保存在磁盘上，或通过网络传输，以达到以后恢复成原来的对象。
序列化机制使得对象可以脱离程序的运行而独立存在。Android中则是使用Parcelable接口来序列化，以便将这些对象放到
一个Intent或者Bundle里面，然后再传递。

## Hash（哈希）的定义、作用、实际用途
* Hash，一般翻译做“散列”，也有直接音译为”哈希“的，就是把任意长度的输入（又叫做预映射， pre-image），通过散列算法，
变换成固定长度的输出，该输出就是散列值。这种转换是一种压缩映射，也就是，散列值的空间通常远小于输入的空间，不同的输入
可能会散列成相同的输出，而不可能从散列值来唯一的确定输入值。简单的说就是一种将任意长度的消息压缩到某一固定长度的消息摘要的函数。
Hash主要用于信息安全领域中加密算法，他把一些不同长度的信息转化成杂乱的128位的编码里,叫做HASH值. 也可以说，
Hash就是找到一种数据内容和数据存放地址之间的映射关系
* Hash算法在信息安全方面的应用主要体现在以下的3个方面：
1) 文件校验:
我们比较熟悉的校验算法有奇偶校验和CRC校验，这2种校验并没有抗数据篡改的能力，它们一定程度上能检测并纠正数据传输中的信道误码，
但却不能防止对数据的恶意破坏。MD5 Hash算法的"数字指纹"特性，使它成为目前应用最广泛的一种文件完整性校验和(Checksum)算法，
不少Unix系统有提供计算md5 checksum的命令。
2) 数字签名:
Hash 算法也是现代密码体系中的一个重要组成部分。由于非对称算法的运算速度较慢，所以在数字签名协议中，单向散列函数扮演了一个
重要的角色。 对 Hash 值，又称"数字摘要"进行数字签名，在统计上可以认为与对文件本身进行数字签名是等效的。而且这样的协议还有其他的优点。
3) 鉴权协议:
如下的鉴权协议又被称作挑战--认证模式：在传输信道是可被侦听，但不可被篡改的情况下，这是一种简单而安全的方法。

## [登录和第三方授权的区别、Basic token，Bearer token、第三方授权的完整流程](https://blog.csdn.net/qq_31339141/article/details/103888903)

## TCP/IP协议族

* 概念：是一个网络通信模型，以及一整个网络传输协议家族，为互联网的基础通信架构。该协议家族的两个核心协议：TCP（传输控制协议）
和IP（网际协议），为该家族中最早通过的标准。
* OSI七层模型：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层
* TCP/IP模型：链路层、网络层、传输层、应用层
* [TCP三次握手,四次挥手：](https://www.jianshu.com/p/ef892323e68f)
    TCP标志位一共有6种，分别是：
    1. SYN(synchronous)： 发送/同步标志，用来建立连接，和下面的第二个标志位ACK搭配使用。连接开始时，SYN=1，ACK=0，
    代表连接开始但是未获得响应。当连接被响应的时候，标志位会发生变化，其中ACK会置为1，代表确认收到连接请求，
    此时的标志位变成了 SYN=1，ACK=1。
    2. ACK(acknowledgement)：确认标志，表示确认收到请求。
    3. PSH(push) ：表示推送操作，就是指数据包到达接收端以后，不对其进行队列处理，而是尽可能的将数据交给应用程序处理；
    4. FIN(finish)：结束标志，用于结束一个TCP会话；
    5. RST(reset)：重置复位标志，用于复位对应的TCP连接。
    6. URG(urgent)：紧急标志，用于保证TCP连接不被中断，并且督促中间层设备尽快处理。
    此外，还有两个序号：
    1. Sequence number ：顺序号，发送数据包中的第一个字节的序列号，一般为小写的seq。
    2. Acknowledge number：确认号，响应前面的seq，值为seq+1，可以理解为期望下次发出的序列号为seq+1；
    1) 三次握手  
        第一次握手: 建立连接。客户端发送连接请求，发送SYN报文，将seq设置为0。然后，客户端进入SYN_SEND状态，等待服务器的确认。  
        第二次握手: 服务器收到客户端的SYN报文段。需要对这个SYN报文段进行确认，发送ACK报文，将ack设置为1。同时，自己还要  
        发送SYN请求信息，将seq为0。服务器端将上述所有信息一并发送给客户端，此时服务器进入SYN_RECV状态。  
        第三次握手: 客户端收到服务器的ACK和SYN报文后，进行确认，然后将ack设置为1，seq设置为1，向服务器发送ACK报文段，这个报文段  
        发送完毕以后，客户端和服务器端都进入ESTABLISHED状态，完成TCP三次握手。  
    
    2) 四次挥手  
        第一次挥手：客户端发送一个FIN，用来关闭客户端到服务器的数据传送，客户端进入FIN_WAIT_1状态。  
        第二次挥手：服务器收到FIN后，发送一个ACK给客户端，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号），  
        服务器进入CLOSE_WAIT状态  
        第三次挥手：服务器发送一个FIN，用来关闭服务器到客户端的数据传送，服务器进入LAST_ACK状态  
        第四次挥手：客户端收到FIN后，客户端进入TIME_WAIT状态，接着发送一个ACK给服务器，确认序号为收到序号+1，  
        服务器进入CLOSED状态，完成四次挥手。  
        
* TCP与UDP的区别：
    1. TCP面向连接（如打电话要先拨号建立连接）;UDP是无连接的，即发送数据之前不需要建立连接  
    2. TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保证可靠交付  
    3. TCP面向字节流，实际上是TCP把数据看成一连串无结构的字节流;UDP是面向报文的  
    4. 每一条TCP连接只能是点到点的;UDP支持一对一，一对多，多对一和多对多的交互通信  
    5. TCP首部开销20字节;UDP的首部开销小，只有8个字节  
    6. TCP的逻辑通信信道是全双工的可靠信道，UDP则是不可靠信道  
    
## [Socket长连接](https://juejin.cn/post/6844903630047281159)

## HTTPS
* 概念：超文本传输安全协议（英语：Hypertext Transfer Protocol Secure，缩写：HTTPS，常称为HTTP over TLS，  
HTTP over SSL或HTTP Secure）是一种通过计算机网络进行安全通信的传输协议。HTTPS经由HTTP进行通信，但利用SSL/TLS来加密数据包。  
HTTPS开发的主要目的，是提供对网站服务器的身份认证，保护交换数据的隐私与完整性。
* HTTPS是在HTTP上建立SSL加密层，并对传输数据进行加密，是HTTP协议的安全版。HTTPS主要作用是：  
    1) 对数据进行加密，并建立一个信息安全通道，来保证传输过程中的数据安全  
    2) 对网站服务器进行真实身份认证  
* HTTPS通信流程  
    HTTPS通信主要包括几个节点，发起请求、验证身份、协商秘钥、加密会话，具体流程如下（此例子只有客户端对服务端的单向验证）：  
    1) 客户端向服务端发起建立HTTPS请求  
    2) 服务器向客户端发送数字证书  
    3) 客户端验证数字证书，证书验证通过后客户端生成会话密钥（双向验证则此处客户端也会向服务器发送证书）  
    4) 服务器生成会话密钥（双向验证此处服务端也会对客户端的证书验证）  
    5) 客户端与服务端开始进行加密会话  
    
## [线程池](https://juejin.cn/post/6844903889678893063)

## Volatile
*  Volatile  
  1) 保证了不同线程对这个变量进行操作时的可见性即一个线程修改了某个变量 的值，这新值对其他线程来是立即可见的。  
  2) 禁止进行指令重排序。   
* synchronized 和 volatile 关键字的作用和区别  
  volatile 本质是在告诉 jvm 当前变量在寄存器(工作内存)中的值是不确定的， 需从主存中读取;  
  synchronized 则是锁定当前变量，只有当前线程可以访问该变量，其它线程被阻塞住。   
  区别
1) volatile 仅能使用在变量级别;synchronized 则可以使用在变量、方法、和类级别的。  
2) volatile 仅能实现变量的修改可见性，并不能保证原子性;synchronized 则可以保证变量的修改可见性和原子性。  
3) volatile 不会造成线程的阻塞;synchronized 可能会造成线程的阻塞。  
4) volatile 标记的变量不会被编译器优化;synchronized 标记的变量可以被编译器优化

## [Handle机制](https://juejin.cn/post/6844903783139393550)
主要涉及的角色如下所示:  
* message:消息。  
* MessageQueue:消息队列，负责消息的存储与管理，负责管理由 Handler 发送过来的 Message。读取会自动删除消息，单链表维护，插入和删除  
上有优势。在其 next()方法中会无限循环，不断判断是否有消息，有就返回这条消息并移除。  
* Looper:消息循环器，负责关联线程以及消息的分发，在该线程下从 MessageQueue 获取 Message，分发给 Handler，Looper 创建的时候会  
创建一个 MessageQueue，调用 loop()方法的时候消息循环开始，其中会不断调用 messageQueue 的 next()方法，当有消息就处理，否则阻塞在  
messageQueue 的 next()方法中。当 Looper 的 quit()被调用的时候会调用messageQueue 的 quit()，此时 next()会返回 null，  
然后 loop()方法也就跟着退出。  
* Handler:消息处理器，负责发送并处理消息，面向开发者，提供 API，并隐藏背后实现的细节。  

整个消息的循环流程还是比较清晰的，具体说来:  
1) Handler 通过 sendMessage()发送消息 Message 到消息队列 MessageQueue。  
2) Looper 通过 loop()不断提取触发条件的 Message，并将 Message 交 给对应的 target handler 来处理。  
3) target handler 调用自身的 handleMessage()方法来处理 Message。  

## [Service和Activity的相互通信](https://www.jianshu.com/p/4b0cbe068555)

## [深入理解JVM的内存结构及GC机制](https://juejin.cn/post/6844903513248497677)

## [OkHttp源码分析](https://juejin.cn/post/6881436122950402056)

## [事件分发机制](https://juejin.cn/post/6921238915143696392)

## [深入浅出AIDL](https://juejin.cn/post/6844903498044162056)

## [View的绘制全流程](https://juejin.cn/post/6844904042175397902)

## [Serializable 和Parcelable 的区别](https://juejin.cn/post/6883309627933458445)

## [隐式跳转](https://juejin.cn/post/6844903506822840328)